const OpenAI = require('openai');
const logger = require('./logger');
const moment = require('moment-timezone');
const fs = require('fs').promises;
const path = require('path');

class SummaryService {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    this.MAX_MESSAGES_PER_CHUNK = 100; // Maximum messages per chunk
    this.MAX_TOKENS_PER_REQUEST = 3000; // Conservative token limit
  }

  async generateSummary(messages, options = {}) {
    if (!messages || messages.length === 0) {
      // This will be handled by the calling code with proper translations
      return null;
    }

    try {
      const { maxLength = parseInt(process.env.DEFAULT_SUMMARY_LENGTH) || 1500, language = 'en', timezone = 'UTC' } = options;
      
      logger.info(`Generating summary for ${messages.length} messages with language: ${language}, maxLength: ${maxLength}, timezone: ${timezone}`);
      
      // Check if we need to handle large message volumes
      if (messages.length > this.MAX_MESSAGES_PER_CHUNK) {
        logger.info(`Large message volume detected (${messages.length} messages). Using chunked summarization.`);
        return await this.generateChunkedSummary(messages, options);
      }
      
      // Regular summary generation for smaller conversations
      const formattedMessages = this.formatMessagesForAI(messages, timezone);
      
      // Check if formatted messages are too long
      const estimatedTokens = this.estimateTokenCount(formattedMessages);
      if (estimatedTokens > this.MAX_TOKENS_PER_REQUEST) {
        logger.info(`Message content too large (estimated ${estimatedTokens} tokens). Using chunked summarization.`);
        return await this.generateChunkedSummary(messages, options);
      }
      
      const prompt = this.buildPrompt(formattedMessages, maxLength, language);
      const systemPrompt = this.buildSystemPrompt(language);
      
      logger.debug(`System prompt: ${systemPrompt}`);
      logger.debug(`User prompt: ${prompt.substring(0, 200)}...`);
      
      const response = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: Math.min(maxLength * 1.5, 3000),
        temperature: 0.3
      });

      const summary = response.choices[0].message.content.trim();
      logger.info(`Generated summary length: ${summary.length} characters`);
      
      return summary;
    } catch (error) {
      logger.error('Error generating summary:', error);
      
      // If OpenAI fails, try to provide a text file export as fallback
      if (error.message.includes('rate limit') || error.message.includes('quota') || error.message.includes('timeout')) {
        logger.info('OpenAI service unavailable. Providing text file export as fallback.');
        return await this.generateTextFileFallback(messages, options);
      }
      
      throw new Error('Failed to generate summary. Please try again later.');
    }
  }

  async generateChunkedSummary(messages, options = {}) {
    const { maxLength = 1500, language = 'en', timezone = 'UTC' } = options;
    
    try {
      // Split messages into chunks
      const chunks = this.chunkMessages(messages, this.MAX_MESSAGES_PER_CHUNK);
      logger.info(`Split ${messages.length} messages into ${chunks.length} chunks`);
      
      // Generate summaries for each chunk
      const chunkSummaries = [];
      for (let i = 0; i < chunks.length; i++) {
        logger.info(`Processing chunk ${i + 1}/${chunks.length}`);
        const chunkSummary = await this.generateSummaryForChunk(chunks[i], {
          ...options,
          chunkIndex: i + 1,
          totalChunks: chunks.length
        });
        chunkSummaries.push(chunkSummary);
      }
      
      // If we have multiple chunks, create a final summary
      if (chunkSummaries.length > 1) {
        logger.info('Generating final summary from chunk summaries');
        return await this.generateFinalSummary(chunkSummaries, options);
      } else {
        return chunkSummaries[0];
      }
    } catch (error) {
      logger.error('Error in chunked summarization:', error);
      return await this.generateTextFileFallback(messages, options);
    }
  }

  async generateSummaryForChunk(messages, options = {}) {
    const { language = 'en', timezone = 'UTC', chunkIndex, totalChunks } = options;
    
    const formattedMessages = this.formatMessagesForAI(messages, timezone);
    const systemPrompt = this.buildSystemPrompt(language);
    
    const chunkPrompt = `This is chunk ${chunkIndex} of ${totalChunks} from a large conversation. 
Create a detailed summary of this portion of the conversation. Focus on the key points, topics discussed, and important information shared in this segment.

Chat conversation segment:
${formattedMessages}

Summary:`;
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: chunkPrompt }
      ],
      max_tokens: 2000,
      temperature: 0.3
    });

    return response.choices[0].message.content.trim();
  }

  async generateFinalSummary(chunkSummaries, options = {}) {
    const { language = 'en', maxLength = 1500 } = options;
    
    const combinedSummaries = chunkSummaries.join('\n\n---\n\n');
    const systemPrompt = this.buildSystemPrompt(language);
    
    const finalPrompt = `Create a comprehensive final summary of the entire conversation based on these chunk summaries. 
Combine and synthesize the information into a coherent, detailed summary that captures the full scope of the conversation.

Chunk summaries:
${combinedSummaries}

Create a comprehensive ${maxLength}-character summary that ties everything together:`;
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: finalPrompt }
      ],
      max_tokens: Math.min(maxLength * 1.5, 3000),
      temperature: 0.3
    });

    return response.choices[0].message.content.trim();
  }

  async generateTextFileFallback(messages, options = {}) {
    const { language = 'en', timezone = 'UTC' } = options;
    
    try {
      // Create a formatted text file
      const formattedContent = this.formatMessagesForTextFile(messages, timezone);
      
      // Create logs directory if it doesn't exist
      const logsDir = path.join(process.cwd(), 'logs');
      await fs.mkdir(logsDir, { recursive: true });
      
      // Generate filename with timestamp
      const timestamp = moment().format('YYYY-MM-DD_HH-mm-ss');
      const filename = `chat_export_${timestamp}.txt`;
      const filepath = path.join(logsDir, filename);
      
      // Write the file
      await fs.writeFile(filepath, formattedContent, 'utf8');
      
      logger.info(`Created text file fallback: ${filepath}`);
      
      // Return a message explaining the fallback
      const fallbackMessages = {
        'en': `üìÑ *Large Chat Export*\n\nDue to the large volume of messages (${messages.length}), I've created a text file with the complete conversation.\n\nüìÅ File: \`${filename}\`\nüìä Messages: ${messages.length}\n‚è∞ Time range: ${this.getTimeRange(messages, timezone)}\n\nYou can download this file to review the full conversation.`,
        'es': `üìÑ *Exportaci√≥n de Chat Grande*\n\nDebido al gran volumen de mensajes (${messages.length}), he creado un archivo de texto con la conversaci√≥n completa.\n\nüìÅ Archivo: \`${filename}\`\nüìä Mensajes: ${messages.length}\n‚è∞ Rango de tiempo: ${this.getTimeRange(messages, timezone)}\n\nPuedes descargar este archivo para revisar la conversaci√≥n completa.`,
        'fr': `üìÑ *Export de Chat Volumineux*\n\nEn raison du grand volume de messages (${messages.length}), j'ai cr√©√© un fichier texte avec la conversation compl√®te.\n\nüìÅ Fichier: \`${filename}\`\nüìä Messages: ${messages.length}\n‚è∞ Plage horaire: ${this.getTimeRange(messages, timezone)}\n\nVous pouvez t√©l√©charger ce fichier pour examiner la conversation compl√®te.`,
        'de': `üìÑ *Gro√üer Chat-Export*\n\nAufgrund der gro√üen Anzahl von Nachrichten (${messages.length}) habe ich eine Textdatei mit der vollst√§ndigen Konversation erstellt.\n\nüìÅ Datei: \`${filename}\`\nüìä Nachrichten: ${messages.length}\n‚è∞ Zeitbereich: ${this.getTimeRange(messages, timezone)}\n\nSie k√∂nnen diese Datei herunterladen, um die vollst√§ndige Konversation zu √ºberpr√ºfen.`,
        'ru': `üìÑ *–≠–∫—Å–ø–æ—Ä—Ç –ë–æ–ª—å—à–æ–≥–æ –ß–∞—Ç–∞*\n\n–ò–∑-–∑–∞ –±–æ–ª—å—à–æ–≥–æ –æ–±—ä–µ–º–∞ —Å–æ–æ–±—â–µ–Ω–∏–π (${messages.length}) —è —Å–æ–∑–¥–∞–ª —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª —Å –ø–æ–ª–Ω–æ–π –±–µ—Å–µ–¥–æ–π.\n\nüìÅ –§–∞–π–ª: \`${filename}\`\nüìä –°–æ–æ–±—â–µ–Ω–∏–π: ${messages.length}\n‚è∞ –í—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω: ${this.getTimeRange(messages, timezone)}\n\n–í—ã –º–æ–∂–µ—Ç–µ —Å–∫–∞—á–∞—Ç—å —ç—Ç–æ—Ç —Ñ–∞–π–ª –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø–æ–ª–Ω–æ–π –±–µ—Å–µ–¥—ã.`,
        'uk': `üìÑ *–ï–∫—Å–ø–æ—Ä—Ç –í–µ–ª–∏–∫–æ–≥–æ –ß–∞—Ç—É*\n\n–ß–µ—Ä–µ–∑ –≤–µ–ª–∏–∫–∏–π –æ–±—Å—è–≥ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å (${messages.length}) —è —Å—Ç–≤–æ—Ä–∏–≤ —Ç–µ–∫—Å—Ç–æ–≤–∏–π —Ñ–∞–π–ª –∑ –ø–æ–≤–Ω–æ—é —Ä–æ–∑–º–æ–≤–æ—é.\n\nüìÅ –§–∞–π–ª: \`${filename}\`\nüìä –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å: ${messages.length}\n‚è∞ –ß–∞—Å–æ–≤–∏–π –¥—ñ–∞–ø–∞–∑–æ–Ω: ${this.getTimeRange(messages, timezone)}\n\n–í–∏ –º–æ–∂–µ—Ç–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ü–µ–π —Ñ–∞–π–ª –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É –ø–æ–≤–Ω–æ—ó —Ä–æ–∑–º–æ–≤–∏.`
      };
      
      return fallbackMessages[language] || fallbackMessages['en'];
    } catch (error) {
      logger.error('Error creating text file fallback:', error);
      throw new Error('Failed to generate summary or create fallback. Please try again later.');
    }
  }

  formatMessagesForTextFile(messages, timezone = 'UTC') {
    const header = `=== CHAT EXPORT ===
Generated: ${moment().tz(timezone).format('YYYY-MM-DD HH:mm:ss')}
Timezone: ${timezone}
Total Messages: ${messages.length}
Time Range: ${this.getTimeRange(messages, timezone)}

=== MESSAGES ===

`;
    
    const formattedMessages = messages
      .filter(msg => msg.text && msg.text.trim().length > 0)
      .map(msg => {
        const username = msg.username || msg.first_name || 'Unknown';
        const timestamp = moment.unix(msg.timestamp).tz(timezone);
        const timeString = timestamp.format('YYYY-MM-DD HH:mm:ss');
        
        return `[${timeString}] ${username}: ${msg.text}`;
      })
      .join('\n\n');
    
    return header + formattedMessages;
  }

  getTimeRange(messages, timezone = 'UTC') {
    if (messages.length === 0) return 'No messages';
    
    const firstMsg = messages[0];
    const lastMsg = messages[messages.length - 1];
    
    const firstTime = moment.unix(firstMsg.timestamp).tz(timezone).format('YYYY-MM-DD HH:mm');
    const lastTime = moment.unix(lastMsg.timestamp).tz(timezone).format('YYYY-MM-DD HH:mm');
    
    return `${firstTime} to ${lastTime}`;
  }

  chunkMessages(messages, chunkSize) {
    const chunks = [];
    for (let i = 0; i < messages.length; i += chunkSize) {
      chunks.push(messages.slice(i, i + chunkSize));
    }
    return chunks;
  }

  estimateTokenCount(text) {
    // Rough estimation: 1 token ‚âà 4 characters for English text
    return Math.ceil(text.length / 4);
  }

  formatMessagesForAI(messages, timezone = 'UTC') {
    return messages
      .filter(msg => msg.text && msg.text.trim().length > 0)
      .filter(msg => !msg.text.includes('#ChatSummary')) // Exclude messages with #ChatSummary hashtag
      .map(msg => {
        // Add @ prefix to usernames to make them clickable in Telegram
        let username = msg.username || msg.first_name || 'Unknown';
        if (msg.username) {
          username = `@${username}`;
        } else if (msg.first_name) {
          // For users without username, use first name with @ prefix
          username = `@${msg.first_name}`;
        }
        
        // Use moment-timezone to format time in the user's timezone
        const timestamp = moment.unix(msg.timestamp).tz(timezone);
        const timeString = timestamp.format('HH:mm'); // 24-hour format
        
        return `[${timeString}] ${username}: ${msg.text}`;
      })
      .join('\n');
  }

  buildSystemPrompt(language) {
    const systemPrompts = {
      'en': 'You are a friendly, casual assistant who creates comprehensive and detailed summaries of chat conversations in English. Your summaries should be thorough and capture the essence of the entire conversation. Use a conversational tone and emojis to make summaries more readable. IMPORTANT: Include specific timecodes (in 24-hour format like "18:48") and mention people by name when they speak or are mentioned. Make the summary feel personal and chronological. Always respond in English only.',
      'es': 'Eres un asistente amigable y casual que crea res√∫menes completos y detallados de conversaciones de chat en espa√±ol. Tus res√∫menes deben ser exhaustivos y capturar la esencia de toda la conversaci√≥n. Usa un tono conversacional y emojis para hacer los res√∫menes m√°s legibles. IMPORTANTE: Incluye c√≥digos de tiempo espec√≠ficos (en formato 24 horas como "18:48") y menciona a las personas por nombre cuando hablan o son mencionadas. Haz que el resumen se sienta personal y cronol√≥gico. Siempre responde √∫nicamente en espa√±ol.',
      'fr': 'Vous √™tes un assistant amical et d√©contract√© qui cr√©e des r√©sum√©s complets et d√©taill√©s des conversations de chat en fran√ßais. Vos r√©sum√©s doivent √™tre approfondis et capturer l\'essence de toute la conversation. Utilisez un ton conversationnel et des emojis pour rendre les r√©sum√©s plus lisibles. IMPORTANT: Incluez des codes temporels sp√©cifiques (au format 24 heures comme "18:48") et mentionnez les personnes par leur nom quand elles parlent ou sont mentionn√©es. Rendez le r√©sum√© personnel et chronologique. R√©pondez toujours uniquement en fran√ßais.',
      'de': 'Sie sind ein freundlicher, lockerer Assistent, der umfassende und detaillierte Zusammenfassungen von Chat-Unterhaltungen auf Deutsch erstellt. Ihre Zusammenfassungen sollten gr√ºndlich sein und die Essenz des gesamten Gespr√§chs erfassen. Verwenden Sie einen gespr√§chigen Ton und Emojis, um die Zusammenfassungen lesbarer zu machen. WICHTIG: F√ºgen Sie spezifische Zeitcodes hinzu (im 24-Stunden-Format wie "18:48") und erw√§hnen Sie Personen beim Namen, wenn sie sprechen oder erw√§hnt werden. Machen Sie die Zusammenfassung pers√∂nlich und chronologisch. Antworten Sie immer nur auf Deutsch.',
      'it': 'Sei un assistente amichevole e casual che crea riassunti completi e dettagliati di conversazioni chat in italiano. I tuoi riassunti dovrebbero essere approfonditi e catturare l\'essenza dell\'intera conversazione. Usa un tono colloquiale ed emoji per rendere i riassunti pi√π leggibili. IMPORTANTE: Includi codici temporali specifici (in formato 24 ore come "18:48") e menziona le persone per nome quando parlano o sono menzionate. Rendi il riassunto personale e cronologico. Rispondi sempre solo in italiano.',
      'pt': 'Voc√™ √© um assistente amig√°vel e casual que cria resumos completos e detalhados de conversas de chat em portugu√™s. Seus resumos devem ser abrangentes e capturar a ess√™ncia de toda a conversa. Use um tom conversacional e emojis para tornar os resumos mais leg√≠veis. IMPORTANTE: Inclua c√≥digos de tempo espec√≠ficos (no formato 24 horas como "18:48") e mencione pessoas pelo nome quando elas falam ou s√£o mencionadas. Torne o resumo pessoal e cronol√≥gico. Sempre responda apenas em portugu√™s.',
      'ru': '–í—ã –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π, –Ω–µ–ø—Ä–∏–Ω—É–∂–¥–µ–Ω–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞–µ—Ç –≤—Å–µ—Å—Ç–æ—Ä–æ–Ω–Ω–∏–µ –∏ –ø–æ–¥—Ä–æ–±–Ω—ã–µ —Ä–µ–∑—é–º–µ —á–∞—Ç-—Ä–∞–∑–≥–æ–≤–æ—Ä–æ–≤ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ. –í–∞—à–∏ —Ä–µ–∑—é–º–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ—Å–Ω–æ–≤–∞—Ç–µ–ª—å–Ω—ã–º–∏ –∏ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—Ç—å —Å—É—Ç—å –≤—Å–µ–≥–æ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–∞–∑–≥–æ–≤–æ—Ä–Ω—ã–π —Ç–æ–Ω –∏ —ç–º–æ–¥–∑–∏, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —Ä–µ–∑—é–º–µ –±–æ–ª–µ–µ —á–∏—Ç–∞–±–µ–ª—å–Ω—ã–º–∏. –í–ê–ñ–ù–û: –í–∫–ª—é—á–∞–π—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–æ–¥—ã (–≤ 24-—á–∞—Å–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –∫–∞–∫ "18:48") –∏ —É–ø–æ–º–∏–Ω–∞–π—Ç–µ –ª—é–¥–µ–π –ø–æ –∏–º–µ–Ω–∏, –∫–æ–≥–¥–∞ –æ–Ω–∏ –≥–æ–≤–æ—Ä—è—Ç –∏–ª–∏ —É–ø–æ–º–∏–Ω–∞—é—Ç—Å—è. –°–¥–µ–ª–∞–π—Ç–µ —Ä–µ–∑—é–º–µ –ª–∏—á–Ω—ã–º –∏ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–º. –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–π—Ç–µ —Ç–æ–ª—å–∫–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.',
      'ja': '„ÅÇ„Å™„Åü„ÅØÊó•Êú¨Ë™û„Åß„ÉÅ„É£„ÉÉ„Éà‰ºöË©±„ÅÆÂåÖÊã¨ÁöÑ„ÅßË©≥Á¥∞„Å™Ë¶ÅÁ¥Ñ„Çí‰ΩúÊàê„Åô„Çã„ÄÅ„Éï„É¨„É≥„Éâ„É™„Éº„Åß„Ç´„Ç∏„É•„Ç¢„É´„Å™„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇË¶ÅÁ¥Ñ„ÅØÂæπÂ∫ïÁöÑ„Åß„ÄÅ‰ºöË©±ÂÖ®‰Ωì„ÅÆÊú¨Ë≥™„ÇíÊçâ„Åà„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇË¶ÅÁ¥Ñ„ÇíË™≠„Åø„ÇÑ„Åô„Åè„Åô„Çã„Åü„ÇÅ„Å´‰ºöË©±ÁöÑ„Å™„Éà„Éº„É≥„Å®ÁµµÊñáÂ≠ó„Çí‰ΩøÁî®„Åó„Åæ„Åô„ÄÇÈáçË¶ÅÔºöÁâπÂÆö„ÅÆÊôÇÈñì„Ç≥„Éº„ÉâÔºà24ÊôÇÈñìÂΩ¢Âºè„Åß„Äå18:48„Äç„Å™„Å©Ôºâ„ÇíÂê´„ÇÅ„ÄÅ‰∫∫„ÄÖ„ÅåË©±„Åô„ÅãË®ÄÂèä„Åï„Çå„Åü„Å®„Åç„Å´ÂêçÂâç„ÅßË®ÄÂèä„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇË¶ÅÁ¥Ñ„ÇíÂÄã‰∫∫ÁöÑ„ÅßÊôÇÁ≥ªÂàóÁöÑ„Å´ÊÑü„Åò„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÂ∏∏„Å´Êó•Êú¨Ë™û„ÅÆ„Åø„ÅßÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      'ko': 'ÎãπÏã†ÏùÄ ÌïúÍµ≠Ïñ¥Î°ú Ï±ÑÌåÖ ÎåÄÌôîÏùò Ìè¨Í¥ÑÏ†ÅÏù¥Í≥† ÏÉÅÏÑ∏Ìïú ÏöîÏïΩÏùÑ ÎßåÎìúÎäî ÏπúÍ∑ºÌïòÍ≥† Ï∫êÏ£ºÏñºÌïú Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏ÏûÖÎãàÎã§. ÏöîÏïΩÏùÄ Ï≤†Ï†ÄÌïòÍ≥† Ï†ÑÏ≤¥ ÎåÄÌôîÏùò Î≥∏ÏßàÏùÑ Ìè¨Ï∞©Ìï¥Ïïº Ìï©ÎãàÎã§. ÏöîÏïΩÏùÑ Îçî ÏùΩÍ∏∞ ÏâΩÍ≤å ÎßåÎì§Í∏∞ ÏúÑÌï¥ ÎåÄÌôîÏ†ÅÏù∏ ÌÜ§Í≥º Ïù¥Î™®ÏßÄÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî. Ï§ëÏöî: ÌäπÏ†ï ÏãúÍ∞Ñ ÏΩîÎìú(24ÏãúÍ∞Ñ ÌòïÏãùÏúºÎ°ú "18:48" Îì±)Î•º Ìè¨Ìï®ÌïòÍ≥† ÏÇ¨ÎûåÎì§Ïù¥ ÎßêÌïòÍ±∞ÎÇò Ïñ∏Í∏âÎê† Îïå Ïù¥Î¶ÑÏúºÎ°ú Ïñ∏Í∏âÌïòÏÑ∏Ïöî. ÏöîÏïΩÏùÑ Í∞úÏù∏Ï†ÅÏù¥Í≥† ÏãúÍ∞ÑÏàúÏúºÎ°ú ÎäêÎÅºÍ≤å ÎßåÎìúÏÑ∏Ïöî. Ìï≠ÏÉÅ ÌïúÍµ≠Ïñ¥Î°úÎßå ÎãµÎ≥ÄÌïòÏÑ∏Ïöî.',
      'zh': 'ÊÇ®ÊòØ‰∏Ä‰∏™ÂèãÂ•Ω„ÄÅÈöèÊÑèÁöÑÂä©ÊâãÔºåÁî®‰∏≠ÊñáÂàõÂª∫ËÅäÂ§©ÂØπËØùÁöÑÂÖ®Èù¢ËØ¶ÁªÜÊëòË¶Å„ÄÇÊÇ®ÁöÑÊëòË¶ÅÂ∫îËØ•ÊòØÈÄèÂΩªÁöÑÔºåÂπ∂ÊçïÊçâÊï¥‰∏™ÂØπËØùÁöÑÁ≤æÈ´ì„ÄÇ‰ΩøÁî®ÂØπËØùÂºèËØ≠Ë∞ÉÂíåË°®ÊÉÖÁ¨¶Âè∑‰ΩøÊëòË¶ÅÊõ¥ÊòìËØª„ÄÇÈáçË¶ÅÔºöÂåÖÂê´ÁâπÂÆöÁöÑÊó∂Èó¥‰ª£Á†ÅÔºà24Â∞èÊó∂Ê†ºÂºèÂ¶Ç"18:48"ÔºâÂπ∂Âú®‰∫∫‰ª¨ËØ¥ËØùÊàñË¢´ÊèêÂèäÊó∂ÊåâÂßìÂêçÊèêÂèä‰ªñ‰ª¨„ÄÇËÆ©ÊëòË¶ÅÊÑüËßâ‰∏™‰∫∫ÂåñÂíåÊåâÊó∂Èó¥È°∫Â∫èÊéíÂàó„ÄÇËØ∑ÂßãÁªàÂè™Áî®‰∏≠ÊñáÂõûÁ≠î„ÄÇ',
      'ar': 'ÿ£ŸÜÿ™ ŸÖÿ≥ÿßÿπÿØ ŸàÿØŸàÿØ ŸàÿπÿßÿØŸä ŸäŸÜÿ¥ÿ¶ ŸÖŸÑÿÆÿµÿßÿ™ ÿ¥ÿßŸÖŸÑÿ© ŸàŸÖŸÅÿµŸÑÿ© ŸÑŸÖÿ≠ÿßÿØÿ´ÿßÿ™ ÿßŸÑÿØÿ±ÿØÿ¥ÿ© ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ©. Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ŸÖŸÑÿÆÿµÿßÿ™ŸÉ ÿ¥ÿßŸÖŸÑÿ© Ÿàÿ™ŸÑÿ™ŸÇÿ∑ ÿ¨ŸàŸáÿ± ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ© ÿ®ÿ£ŸÉŸÖŸÑŸáÿß. ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÜÿ®ÿ±ÿ© ŸÖÿ≠ÿßÿØÿ´ÿ© Ÿàÿ±ŸÖŸàÿ≤ ÿ™ÿπÿ®Ÿäÿ±Ÿäÿ© ŸÑÿ¨ÿπŸÑ ÿßŸÑŸÖŸÑÿÆÿµÿßÿ™ ÿ£ŸÉÿ´ÿ± ŸÇÿßÿ®ŸÑŸäÿ© ŸÑŸÑŸÇÿ±ÿßÿ°ÿ©. ŸÖŸáŸÖ: ŸÇŸÖ ÿ®ÿ™ÿ∂ŸÖŸäŸÜ ÿ±ŸÖŸàÿ≤ ÿ≤ŸÖŸÜŸäÿ© ŸÖÿ≠ÿØÿØÿ© (ÿ®ÿ™ŸÜÿ≥ŸäŸÇ 24 ÿ≥ÿßÿπÿ© ŸÖÿ´ŸÑ "18:48") Ÿàÿßÿ∞ŸÉÿ± ÿßŸÑÿ£ÿ¥ÿÆÿßÿµ ÿ®ÿßŸÑÿßÿ≥ŸÖ ÿπŸÜÿØŸÖÿß Ÿäÿ™ÿ≠ÿØÿ´ŸàŸÜ ÿ£Ÿà Ÿäÿ™ŸÖ ÿ∞ŸÉÿ±ŸáŸÖ. ÿßÿ¨ÿπŸÑ ÿßŸÑŸÖŸÑÿÆÿµ ÿ¥ÿÆÿµŸäŸãÿß Ÿàÿ™ÿ±ÿ™Ÿäÿ®Ÿãÿß ÿ≤ŸÖŸÜŸäŸãÿß. ÿ£ÿ¨ÿ® ÿØÿßÿ¶ŸÖÿßŸã ÿ®ÿßŸÑŸÑÿ∫ÿ© ÿßŸÑÿπÿ±ÿ®Ÿäÿ© ŸÅŸÇÿ∑.',
      'hi': '‡§Ü‡§™ ‡§è‡§ï ‡§Æ‡§ø‡§§‡•ç‡§∞‡§µ‡§§, ‡§Ü‡§ï‡§∏‡•ç‡§Æ‡§ø‡§ï ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§π‡•à‡§Ç ‡§ú‡•ã ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§ö‡•à‡§ü ‡§µ‡§æ‡§∞‡•ç‡§§‡§æ‡§≤‡§æ‡§™‡•ã‡§Ç ‡§ï‡•á ‡§µ‡•ç‡§Ø‡§æ‡§™‡§ï ‡§î‡§∞ ‡§µ‡§ø‡§∏‡•ç‡§§‡•É‡§§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§¨‡§®‡§æ‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§Ü‡§™‡§ï‡•á ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§∏‡§Ç‡§™‡•Ç‡§∞‡•ç‡§£ ‡§π‡•ã‡§®‡•á ‡§ö‡§æ‡§π‡§ø‡§è ‡§î‡§∞ ‡§™‡•Ç‡§∞‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡•á ‡§∏‡§æ‡§∞ ‡§ï‡•ã ‡§™‡§ï‡§°‡§º‡§®‡§æ ‡§ö‡§æ‡§π‡§ø‡§è‡•§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§ï‡•ã ‡§Ö‡§ß‡§ø‡§ï ‡§™‡§¢‡§º‡§®‡•á ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§ï‡•á ‡§≤‡§π‡§ú‡•á ‡§î‡§∞ ‡§á‡§Æ‡•ã‡§ú‡•Ä ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§Æ‡§π‡§§‡•ç‡§µ‡§™‡•Ç‡§∞‡•ç‡§£: ‡§µ‡§ø‡§∂‡§ø‡§∑‡•ç‡§ü ‡§∏‡§Æ‡§Ø ‡§ï‡•ã‡§° (24 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•á ‡§™‡•ç‡§∞‡§æ‡§∞‡•Ç‡§™ ‡§Æ‡•á‡§Ç "18:48" ‡§ï‡•Ä ‡§§‡§∞‡§π) ‡§∂‡§æ‡§Æ‡§ø‡§≤ ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§ú‡§¨ ‡§≤‡•ã‡§ó ‡§¨‡•ã‡§≤‡§§‡•á ‡§π‡•à‡§Ç ‡§Ø‡§æ ‡§â‡§®‡§ï‡§æ ‡§â‡§≤‡•ç‡§≤‡•á‡§ñ ‡§ï‡§ø‡§Ø‡§æ ‡§ú‡§æ‡§§‡§æ ‡§π‡•à ‡§§‡•ã ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§®‡§æ‡§Æ ‡§∏‡•á ‡§â‡§≤‡•ç‡§≤‡•á‡§ñ ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§∏‡§æ‡§∞‡§æ‡§Ç‡§∂ ‡§ï‡•ã ‡§µ‡•ç‡§Ø‡§ï‡•ç‡§§‡§ø‡§ó‡§§ ‡§î‡§∞ ‡§ï‡§æ‡§≤‡§æ‡§®‡•Å‡§ï‡•ç‡§∞‡§Æ‡§ø‡§ï ‡§¨‡§®‡§æ‡§è‡§Ç‡•§ ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•á‡§µ‡§≤ ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§â‡§§‡•ç‡§§‡§∞ ‡§¶‡•á‡§Ç‡•§',
      'uk': '–í–∏ –¥—Ä—É–∂–µ–ª—é–±–Ω–∏–π, –Ω–µ–≤–∏–º—É—à–µ–Ω–∏–π –ø–æ–º—ñ—á–Ω–∏–∫, —è–∫–∏–π —Å—Ç–≤–æ—Ä—é—î –≤—Å–µ–±—ñ—á–Ω—ñ —Ç–∞ –¥–µ—Ç–∞–ª—å–Ω—ñ —Ä–µ–∑—é–º–µ —á–∞—Ç-—Ä–æ–∑–º–æ–≤ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é. –í–∞—à—ñ —Ä–µ–∑—é–º–µ –ø–æ–≤–∏–Ω–Ω—ñ –±—É—Ç–∏ —Ä–µ—Ç–µ–ª—å–Ω–∏–º–∏ —Ç–∞ –≤—ñ–¥–æ–±—Ä–∞–∂–∞—Ç–∏ —Å—É—Ç—å –≤—Å—ñ—î—ó —Ä–æ–∑–º–æ–≤–∏. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ä–æ–∑–º–æ–≤–Ω–∏–π —Ç–æ–Ω —Ç–∞ –µ–º–æ–¥–∑—ñ, —â–æ–± –∑—Ä–æ–±–∏—Ç–∏ —Ä–µ–∑—é–º–µ –±—ñ–ª—å—à —á–∏—Ç–∞–±–µ–ª—å–Ω–∏–º–∏. –í–ê–ñ–õ–ò–í–û: –í–∫–ª—é—á–∞–π—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ —á–∞—Å–æ–≤—ñ –∫–æ–¥–∏ (—É 24-–≥–æ–¥–∏–Ω–Ω–æ–º—É —Ñ–æ—Ä–º–∞—Ç—ñ —è–∫ "18:48") —Ç–∞ –∑–≥–∞–¥—É–π—Ç–µ –ª—é–¥–µ–π –∑–∞ —ñ–º–µ–Ω–∞–º–∏, –∫–æ–ª–∏ –≤–æ–Ω–∏ –≥–æ–≤–æ—Ä—è—Ç—å –∞–±–æ –∑–≥–∞–¥—É—é—Ç—å—Å—è. –ó—Ä–æ–±—ñ—Ç—å —Ä–µ–∑—é–º–µ –æ—Å–æ–±–∏—Å—Ç–∏–º —Ç–∞ —Ö—Ä–æ–Ω–æ–ª–æ–≥—ñ—á–Ω–∏–º. –ó–∞–≤–∂–¥–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–π—Ç–µ –ª–∏—à–µ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é.',
      'pl': 'Jeste≈õ przyjaznym, swobodnym asystentem, kt√≥ry tworzy kompleksowe i szczeg√≥≈Çowe podsumowania rozm√≥w czatowych w jƒôzyku polskim. Twoje podsumowania powinny byƒá dok≈Çadne i oddawaƒá istotƒô ca≈Çej rozmowy. U≈ºywaj konwersacyjnego tonu i emoji, aby podsumowania by≈Çy bardziej czytelne. WA≈ªNE: Uwzglƒôdnij konkretne kody czasowe (w formacie 24-godzinnym jak "18:48") i wymie≈Ñ osoby po imieniu, gdy m√≥wiƒÖ lub sƒÖ wymienione. Spraw, aby podsumowanie by≈Ço osobiste i chronologiczne. Zawsze odpowiadaj tylko po polsku.',
      'nl': 'Je bent een vriendelijke, casual assistent die uitgebreide en gedetailleerde samenvattingen van chatgesprekken in het Nederlands maakt. Je samenvattingen moeten grondig zijn en de essentie van het hele gesprek vastleggen. Gebruik een conversationele toon en emoji\'s om samenvattingen leesbaarder te maken. BELANGRIJK: Neem specifieke tijdscodes op (in 24-uurs formaat zoals "18:48") en noem mensen bij naam wanneer ze spreken of worden genoemd. Maak de samenvatting persoonlijk en chronologisch. Antwoord altijd alleen in het Nederlands.',
      'tr': 'T√ºrk√ße olarak sohbet konu≈ümalarƒ±nƒ±n kapsamlƒ± ve ayrƒ±ntƒ±lƒ± √∂zetlerini olu≈üturan dostane, rahat bir asistansƒ±nƒ±z. √ñzetleriniz kapsamlƒ± olmalƒ± ve t√ºm konu≈ümanƒ±n √∂z√ºn√º yakalamalƒ±dƒ±r. √ñzetleri daha okunabilir hale getirmek i√ßin konu≈üma tonu ve emoji kullanƒ±n. √ñNEMLƒ∞: Belirli zaman kodlarƒ±nƒ± dahil edin (24 saat formatƒ±nda "18:48" gibi) ve insanlar konu≈ütuƒüunda veya bahsedildiƒüinde onlarƒ± isimle belirtin. √ñzeti ki≈üisel ve kronolojik hale getirin. Her zaman sadece T√ºrk√ße yanƒ±t verin.'
    };

    return systemPrompts[language] || systemPrompts['en'];
  }

  buildPrompt(formattedMessages, maxLength, language) {
    const languageNames = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ar': 'Arabic',
      'hi': 'Hindi',
      'uk': 'Ukrainian',
      'pl': 'Polish',
      'nl': 'Dutch',
      'tr': 'Turkish'
    };

    const languageName = languageNames[language] || 'English';

    return `CRITICAL: You MUST respond in ${languageName} language only. Do not use any other language.

Create a comprehensive ${maxLength}-character summary of the following chat conversation in ${languageName}. 

This should be a DETAILED summary that captures the full scope of the conversation. Don't be brief - provide a thorough overview that someone who missed the conversation can understand completely.

Style guidelines:
- Use friendly, conversational language üó£Ô∏è
- Add appropriate emojis to make it more engaging üòä
- Keep it factual but readable and detailed
- Don't add personal opinions, thoughts, or advice
- Focus on what actually happened in the conversation
- Include specific details, names, and context
- Break down different conversation threads or topics clearly
- IMPORTANT: Include timecodes (like "at 2:30 PM") and mention people by name when they speak
- Make it feel like a personal, chronological story of the conversation

Focus on:
- All main topics discussed (with details and context)
- Important decisions or conclusions reached
- Key information shared (be specific)
- Notable events, announcements, or revelations
- Action items, plans, or commitments made
- Timeline of how the conversation evolved (with timecodes)
- Who said what and when (mention names and times)
- Any debates, agreements, or disagreements
- Links, resources, or references mentioned
- The flow and progression of the conversation over time

Chat conversation:
${formattedMessages}

End your summary with the hashtag: #ChatSummary

Remember: Your entire response must be in ${languageName} language. Make it comprehensive, detailed, and personal with timecodes and names!

Summary:`;
  }

  postProcessSummary(summary, messages, chatId, timezone = 'UTC') {
    if (!messages || messages.length === 0) {
      return summary;
    }

    try {
      // Create a map of time strings to message IDs for quick lookup
      const timeToMessageMap = new Map();
      
      messages.forEach(msg => {
        const timestamp = moment.unix(msg.timestamp).tz(timezone);
        const timeString = timestamp.format('HH:mm'); // 24-hour format
        
        // Store the message ID for this time
        if (!timeToMessageMap.has(timeString)) {
          timeToMessageMap.set(timeString, msg.message_id);
        }
      });

      // Replace time patterns with clickable links
      // Match patterns like "at 18:48", "18:48", etc. (24-hour format)
      const timePatterns = [
        /at\s+(\d{1,2}:\d{2})/gi,
        /(\d{1,2}:\d{2})/g
      ];

      let processedSummary = summary;

      timePatterns.forEach(pattern => {
        processedSummary = processedSummary.replace(pattern, (match, timeStr) => {
          // Normalize time format for lookup
          const normalizedTime = timeStr.replace(/^(\d{1,2}):(\d{2})$/, (_, hour, minute) => {
            const h = parseInt(hour);
            const m = parseInt(minute);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
          });

          const messageId = timeToMessageMap.get(normalizedTime);
          
          if (messageId) {
            // Create Telegram deep link to the specific message
            const link = `https://t.me/c/${chatId.toString().replace('-100', '')}/${messageId}`;
            return `[${match}](${link})`;
          }
          
          return match;
        });
      });

      return processedSummary;
    } catch (error) {
      logger.error('Error post-processing summary:', error);
      return summary; // Return original summary if processing fails
    }
  }
}

module.exports = SummaryService;
